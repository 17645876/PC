并行库
在最后一个研讨会中, 我们将学习如何使用一个名为 boost. 计算的并行库。教程代码托管在 github https://github.com/gcielniak/OpenCLTutorials上。您可以从 zip 文件 (绿色 "克隆或下载" 按钮) 下载并提取存储库, 也可以通过从命令行发出"git 克隆 https://github.com/gcielniak/OpenCL-Tutorials.git " 命令克隆到本地目录。这次我们将使用教程4。有关车间及其结构的详细信息, 以及有关 opencl 的更多技术细节, 请参阅前面的教程说明。

1引导. 计算
boost. 计算 (https://github.com/boostorg/compute) 是围绕 opencl 功能的类似 stl 的 c++ 包装器, 它以高效且易于使用的方式实现了许多基本算法, 如转换、减少、排序等。它是作为 boost 库 (http://www.boost.org/) 的一部分而开发的, 这是 c++ 用户中非常流行的模板库。boost. 计算的官方文档可以在这里找到: http://www.boost.org/doc/libs/develop/libs/compute/doc/ htmlindex. html # 弘扬 _ 算. ination. 导言。

任务 4u: 阅读文档最多""高级主题""熟悉自己的图书馆.

2向量加法
在第一个示例中, 我们将重新访问第一个教程中的矢量加法代码。提供的程序添加了两个向量 a 和 b, 并将结果存储在向量 c 中. 首先检查提供的代码, 然后生成并运行它。将此代码的复杂性与 opencl 中的原始实现进行比较。

如果您不熟悉 stl, 某些函数调用可能看起来有点神秘。查看下面的教程中介绍的 stl 的基础知识可能是一个好主意: http://www.tutorialspoint.com/cplusplus/cpp_stl_tutorial.htm。

为了更好地理解提供的代码, 让我们看看计算:: 转换函数 (https://boostorg.github.io/compute/boost/compute/transform.html)。转换函数对应于映射并行模式, 并将相同的运算符 (在我们的示例加中) 应用于两个输入向量 (deva, devA) 的所有元素, 并将结果存储在第三个 (devA) 中。作为我们的函数参数, 我们需要提供第一个和最后一个元素的第一个和最后一个元素来定义范围, 以及第二个 (devA) 和第三个 (devA) 的第一个元素。最后两个向量的长度将被假定为与第一个向量相同。矢量属性分别指向矢量的第一个和最后一个元素 () 和结束 ()。

任务 4u: 您可以轻松地更改提供给转换函数的运算符。首先查看文档, 然后尝试减法和乘法运算。

您还可以轻松地添加转换函数可以应用于向量的自定义运算符。例如, 可以通过以下方式声明将2添加到所有元素的运算符:
boost _ comput _ 功能 (int, plus 2, (int x), {返回 x + 2;});

这样的运算符可以与转换函数一起使用:
计算: 转换 (deva 开始 (), deva end (), devc. start (), 再加上 _ 2);

因此, 向量 c 应包含来自向量 a 的所有元素, 附加值为2。使用代码尝试此新功能。

任务 4u: 编写一个名为平方的运算符, 该运算符将每个元素提升到2的功率, 并将其应用于矢量 a 检查最终结果。
任务 4u: 重复上述任务, 但对于浮点数据类型。

3减少

下一个重要函数是计算:: 与并行约简 (https://boostorg.github.io/compute/boost/compute/reduce.html) 相对应的减少。下面的代码演示如何使用加法操作来减少矢量。

int 和;计算: 减少 (deva. start (), deva 结束 (), & 总和);

请先尝试此功能并检查结果。可以为减少运算符指定不同的运算符;如果未指定, 则计算: 假定:p lus。下面一行将产生与上面的代码完全相同的结果:
计算: 减少 (deva 开始 (), deva end (), & 和, 计算::p lus ());

任务 4u: 应用具有减少功能的最小和最大运算符, 并检查结果。
任务 4u: 使用这些函数计算林肯郡在分配中使用的温度记录的三个基本统计信息 (avg, 最小值、最大值)。

4散射 & 聚集
在 boost. 计算中也存在两种并行的散射和聚集模式, 作为计算:: 散射和计算:: 聚集函数(https://boostorg.github.io/compute/boost/计算. html 和https://boostorg.github.io/compute/boost/compute/gather.html), 并且可以以与以前的函数类似的方式使用。这两个函数都将定义映射位置的向量作为附加输入。

任务 4u: 将这两个函数应用于讲座幻灯片中的示例, 并比较结果

5 scas/sort·搜索
我们的模块中介绍的计算库提供的其他功能包括扫描 (包括和独占)、排序和二进制搜索。尝试使用这些函数并检查结果。
任务 4u: 使用排序搜索算法实现直方图函数, 如讲座幻灯片中所示。将此函数应用于指定操作中使用的林肯郡温度记录。

6个平台和设备
到目前为止, 在我们的示例中, 我们已经使用了默认的 opencl 设备。boost. 计算允许选择 opencl 平台和设备, 并将它们排列到不同的上下文中。下面的代码演示如何创建 opencl 上下文和队列, 并在我们的基本矢量加法示例中使用它们:
//
请注意上下文如何用于声明设备缓冲区和队列以执行操作。下面的代码演示如何选择特定的平台和设备:
//
任务 4u: 调整主函数, 因此它可以接受其他命令行参数, 允许选择特定的平台和设备, 类似于我们以前教程中的代码。

7分析
下面的教程演示如何在 boost. 计算: https://boostorg中分析您的代码。github.io/compute/boost_compute/advanced_topics.html#boost_compute.advanced_topics.perfor 的时机。
任务 4u: 对较大的输入向量 (例如10m 元素) 执行减少代码的分析, 并将其性能与我们最初的 opencl 实现进行比较。


8家庭库设置
在家里设置 boost. 计算库的最简单方法是从 blackboard ("研究材料周 B11/boost_1_60_0.zip")下载库包,并将文件直接提取到 c: 驱动器和重命名文件夹设置为 "本地" , 以便提升位于 "c:\ local\ boost_1_60_0"中。它是一个大的文件集合, 因此提取可能需要很长时间 (即10分钟以上!).
